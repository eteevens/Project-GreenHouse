<!DOCTYPE html> <!-- names the type of document, in this case, HTML5 -->
<html>

<head>

<style>

p {
  font-family: verdana;
}

h1 {
  font-family: verdana;
}

img {
  margin: 0;
}

iframe {
  border: 0;
}

.graphics {
  grid-area: graph;
}

.video {
  grid-area: camera;
}

.time-controls {
  grid-area: timing;
}

.other-controls {
  grid-area: controls;
  padding-top: 0%;
}

.layout-container {
  display: grid;
  grid-template-areas:
  'graph graph graph graph camera camera camera'
  'graph graph graph graph camera camera camera'
  'graph graph graph graph camera camera camera'
  'graph graph graph graph timing timing timing'
  'graph graph graph graph timing timing timing'
  'controls controls controls controls timing timing timing';
  grid-template-columns: 12% 12% 12% 12% 12% 12% 12%;
  grid-template-rows: 12% 12% 12% 12% 12% 12%;
  grid-gap: 2%;
  justify-content: center;
}

.layout-container > div {
  text-align: center;
  outline: 1px outset black;
  font-family: verdana;
}

</style>

</head>

<body>

  <!--header and grid layout of the project-->
  <h1 style="text-align:center;"> Project GreenHouse </h1>

  <div class=layout-container>
    <div class=graphics><div>
      <canvas id="live_graph"></canvas>
    </div></div>
    <div class=video><img src="{{ url_for('video_feed_route') }}" height=100%></img>
    </div>
    <div class=time-controls><div id="calendar"></div></div>
    <div class=other-controls width=100%>
        <form id="form_data">
          <label for="temp">Temperature:</label>
          <input type="number" id="temp" name="temp" min="10"><br>
          <label for="water_drip">Water Drip:</label>
          <input type="checkbox" id="water_drip" name="water_drip">
          <label for="lights">Lights:</label>
          <input type="checkbox" id="lights" name="lights">
          <br>
          <input type="submit" value="Submit">
        </form>
    </div>
  </div>

  <!--jquery library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"
  integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ=="
  crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!--xxx library (for the calendar)-->

  <!--twitter bootstrap library (used to read the text stream)-->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.1/js/bootstrap.min.js"
  integrity="sha512-UR25UO94eTnCVwjbXozyeVd6ZqpaAE9naiEUBK/A+QDbfSTQFhPGj5lOR6d8tsgbBk84Ggb5A3EkjsOgPRPcKA=="
  crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!--chart.js library (for the graph) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"
  integrity="sha512-QSkVNOCYLtj73J4hbmVoOV6KVZuMluZlioC+trLpewV8qMjsWqlIQvkn1KGX2StWvPMdWGBqim1xlC8krl1EKQ=="
  crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>

    function generateColor() { //creates a random hsl value color every time the function
      //is called and returns it, this makes the graph have different
      //(but reasonably bright) colored lines
      var hsl = 'hsla(' + Math.floor(Math.random() * 360) + ', 100%, 50%, 1)';
      return hsl;
    }

    /**
 * Fixes the issue with checkbox forms using serializeArray which ordinarily
 * only respond when toggled on.
 *
 * @see https://ourcodeworld.com/articles/read/1030/how-to-change-the-on-and-off-values-to-boolean-true-or-false-from-checkboxes-with-serialization-with-jquery-serialize-and-serializearray
 */
(function ($) {
    $.fn.serialize = function (options) {
        return $.param(this.serializeArray(options));
    };

    $.fn.serializeArray = function (options) {
        var o = $.extend({
            checkboxesAsBools: false
        }, options || {});

        var rselectTextarea = /select|textarea/i;
        var rinput = /text|hidden|password|search|number/i;

        return this.map(function () {
            return this.elements ? $.makeArray(this.elements) : this;
        })
        .filter(function () {
            return this.name && !this.disabled &&
                (this.checked
                || (o.checkboxesAsBools && this.type === 'checkbox')
                || rselectTextarea.test(this.nodeName)
                || rinput.test(this.type));
            })
            .map(function (i, elem) {
                var val = $(this).val();
                return val == null ?
                null :
                $.isArray(val) ?
                $.map(val, function (val, i) {
                    return { name: elem.name, value: val };
                }) :
                {
                    name: elem.name,
                    value: (o.checkboxesAsBools && this.type === 'checkbox') ?
                        (this.checked ? "true" : "false") :
                        val
                };
            }).get();
    };
})(jQuery);


    $("#form_data").submit(function (event) {
      //takes the data from the submission of the form and sends it
      //via AJAX and JSON to the backend for processing

       var outputCount = 3; //the number of output controls

       var userInput = []; //reads in the user's input, which needs to be
       //formatted before being sent

       var outputData = {}; //holds the data to be sent

       for (iterRead = 0; iterRead < outputCount; iterRead++) {
         userInput.push($("#form_data").serializeArray(
           {checkboxesAsBools: true})[iterRead]); //turns the input from the
           //submission into an array with {"name":<nameofinput>, "value":<valueofinput>}
           //elements, corrected for checkbox error

         outputData[userInput[iterRead]["name"]] = userInput[iterRead]["value"];
         //turns the array into a dictionary with <nameofinput>:<valueofinput> elements

         if (outputData[userInput[iterRead]["name"]] === "") {
           //if a input has no value, return an alert, note that this returns
           //a false positive if the checkbox correction (see above) is sending
           //booleans and not boolean strings
           alert('Error, no data inputed');
           event.preventDefault(); //don't send the data
         }
       }

     $.ajax({type:"POST",
              url:"/controls_feed",
              data:JSON.stringify(outputData),
              contentType: "application/json",})

              .fail(function( ) {
                 console.log("Error with the html posting of control_feed");
               });
               //send the data via AJAX as a JSON string to the relative url
               // '/controls_feed', if it fails, write to the console

         event.preventDefault(); //prevent the submission button from attempting
         //to reload the page to submit the form without AJAX
    });


    $(document).ready(function () {

    var inputCount = 3; //the number of different incoming data
    //for the graph

    const dataDisplay = []; //the array of values for the display of the graph,
    //this will hold the data itself as well as the name of the variables, the
    //colors, etc.

    for (iterDisplay = 0; iterDisplay < inputCount; iterDisplay++) {
      //create an empty data element for every incoming data
       dataDisplay.push({data: [], label: ''});
    }

    //holds the actual data, note the maping of the generated color to both
    //the backgroundColor and the borderColor-- this makes the dots and lines
    // the same generated color, this also holds the dataDisplay value
    const dataInfo = {
      datasets: dataDisplay.map(v => {
        var color = generateColor();
        return {...v, backgroundColor: color, borderColor: color}
      })
    };

    //hold the graph's general config data (ie. it's a line graph), as well as
    //the scaling of the graph, which is held at a max 0f 100, this also holds
    //the dataInfo value
    const config = {
      type: 'line',
      labels: [],
      data: dataInfo,
      options: {
        fill: false,
        tension: 0.25,
        responsive: true,
        scales: {
          y: {beginAtZero: true,
              max:100
            }
        },
        animation: false
      }
    };

      const context = document.getElementById('live_graph').getContext('2d');
      //this is where the graph will be published in the HTML

      const live_graph = new Chart(context, config);
      //this creates the graph, note that it passes in both the config and the
      //context (where to put it)

      const source = new EventSource("/graph_feed");
      //create a new source of a json text stream (aka, this is where the data
      //actually is read into the program)

      source.onmessage = function (event) {
        //when the source has a new message, run this event

        const data = JSON.parse(event.data); //the data comes from a translating
        //the JSON sent by the text stream

        if (config.data.labels.length === 10) {
          //when there are 10 labels on the graph, shift over every datapoint
          config.data.labels.shift(); //shift over the labels (aka the time values)
          for (iterShift = 0; iterShift < inputCount; iterShift++) {
            config.data.datasets[iterShift].data.shift(); //shift over the data
          }
        }

        config.data.labels.push(data.time); //add a new label from the text stream
        // (aka the time values)

        var iterUpdate = 0; //this value will keep track of where to push the
        //data (ie. dataset[0], dataset[1], etc)

        for (let value in data) { //iterate through all the keys
          if (value != 'time') { //ignore the key which is 'time', this is the
            //key for the labels so we ignore it

            if (config.data.datasets[iterUpdate].label == String(value)) {
              config.data.datasets[iterUpdate].data.push(data[value]);
              //push the new data from the text stream, only if the label matches
            }
            else if (config.data.datasets[iterUpdate].label != String(value)
            && config.data.datasets[iterUpdate].label === "") {
              //if the label != to the value of the string, and the label is empty,
              //set it equal to the value of the string and push the first bit of data
              config.data.datasets[iterUpdate].label = String(value);
              config.data.datasets[iterUpdate].data.push(data[value]);
            }
            iterUpdate++; //increment the update location
          }
        }

        live_graph.update(); //update the graph
      };
    });

  </script>

</body>

</html>
