import cv2 #openCV for camera controls

import json #to send the data to be displayed on the graph and recieve data
#from the controls
import numpy as np #numpy for random number

from threading import Semaphore #semaphore, protects the frame data

import calendar #calender for the timing controls
from datetime import datetime #date module for current date, time module
#for the current time for the graph

from flask import Flask #flask main
from flask import render_template #html pages
from flask import Response #functions
from flask import stream_with_context #for live graph
from flask import request #for controls and scheduler

import time #allows the random data to wait

graphFrame = {} #the current graph frame
graphFrameSem = Semaphore()

controlsFrame = {} #the current controls frame
controlsFrameSem = Semaphore()

checkRateGraph = 0.5 #how often to check the graph, NEEDS to be same as client

app = Flask(__name__) #initalize the web application

def camera_frames():
    #the camera feed for the page

    vc = cv2.VideoCapture(0) #temporary taking of video feed from computer camera

    while True:
        success, frame = vc.read() #read the camera frame
        (frame_height, frame_width) = frame.shape[:2] #save the current frame size

        resize_percent = 0.50 #rescale the frame by 50%

        #create scaled frame size
        rescale_frame_width = int(frame_width * resize_percent)
        rescale_frame_height = int(frame_height * resize_percent)

        #save dimensions for resize scaling`
        dimensions = (rescale_frame_width, rescale_frame_height)

        #rescale the frame with cv2's interpolation
        frame = cv2.resize(frame, dimensions, interpolation=cv2.INTER_LINEAR)

        if not success:
            break
        else:
            ret, buffer = cv2.imencode('.jpg', frame)
            outputFrame = buffer.tobytes()
            yield(b'--frame\r\n'
                  b'Content-Type: image/jpeg\r\n\r\n' + outputFrame + b'\r\n')

    vc.release()

def graph_display(): #read in graph data to display

    value1 = 0 #triangle wave fake data

    while True:
        '''
        graphFrameSem.acquire()
        graph_data = graphFrame #get the current frame from the graph
        graphFrameSem.release()

        yield f"data:{graph_data}\n\n" #stream data
        '''

        value1 = (value1 + 15) % 100
        value2 = int(np.random.rand() * 100) #random fake data
        value3 = int(np.random.rand() * 100)
        value4 = 95
        value5 = 10
        value6 = 85
        value7 = 50

        data_to_send = {'time':datetime.now().strftime('%H:%M:%S')}
        #adds the time to the json to be sent, this MUST be sent because
        #that is what fills out the y-axis of the graph

        data_to_send['Temperature (in F)'] = value1 #name of the data (to be displayed) : value
        data_to_send['Humidity'] = value2
        data_to_send['Light Level'] = value3
        data_to_send['Max Temperature Set Point'] = value4
        data_to_send['Min Temperature Set Point'] = value5
        data_to_send['Max Humidity Set Point'] = value6
        data_to_send['Day/Night Line'] = value7

        json_data = json.dumps(data_to_send) #turns the data into a JSON string

        yield f"data:{json_data}\n\n"

        time.sleep(checkRateGraph)

def send_controls_data(): #send the controls data
    while True:
        controlsFrameSem.acquire()
        controls_data = controlsFrame #get the current frame of the controls data
        controlsFrameSem.release()

        return json.dumps(controls_data)

@app.route('/') #index of the GUI (the viewable page)
def index():
    return render_template('index.html')

@app.route('/video_feed') #video feed route
def video_feed_route():
    return Response(camera_frames(), mimetype = "multipart/x-mixed-replace; boundary=frame")

@app.route('/graph_feed') #graph feed route
def graph_feed_route():
    response = Response(stream_with_context(graph_display()),
    mimetype='text/event-stream')
    response.headers["Cache-Control"] = "no-cache"
    response.headers["X-Accel-Buffering"] = "no"
    return response

@app.route('/calendar_feed', methods=["POST"]) #calendar feed route
def calendar_feed_route():
    retrieve_cal = request.get_json()
    print(retrieve_cal)
    return json.dumps({'success':True}), 200, {'ContentType':'application/json'}

@app.route('/controls_feed', methods=["POST"]) #controls feed route
def controls_feed_route():
    retrieve_output = request.get_json() #get the user's input from the GUI

    '''
    controlsFrameSem.acquire()
    global controlsFrame
    controlsFrame = retrieve_output
    controlsFrameSem.release()'''

    print(retrieve_output)

    return json.dumps({'success':True}), 200, {'ContentType':'application/json'}

'''
@app.route('/read_client', methods=["POST"]) #read data generated by the client
def read_client_route():
    client_data = request.get_json() #get the data from the data client
    #(the Raspberry Pi code)

    graphFrameSem.acquire()
    global graphFrame
    graphFrame = client_data
    graphFrameSem.release()

    return json.dumps({'success':True}), 200, {'ContentType':'application/json'}

@app.route('/write_client') #write data to the client
def write_client_route():
    return Response(send_controls_data(), mimetype='application/json')
'''
if __name__ == "__main__":
    app.run(host="127.0.0.1", port='5000', debug=True, threaded=True, use_reloader=False)
