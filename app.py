import cv2 #openCV for camera controls

import json #to send the data to be displayed on the graph and recieve data
#from the controls
import numpy as np #numpy for random number

from threading import Semaphore #semaphore, protects the frame data

import calendar #calender for the timing controls
from datetime import datetime #date module for current date, time module
#for the current time for the graph

from flask import Flask #flask main
from flask import render_template #html pages
from flask import Response #functions
from flask import stream_with_context #for live graph
from flask import request #for controls and scheduler

import time #allows the random data to wait

graphFrame = {} #the current graph frame
graphFrameSem = Semaphore()

app = Flask(__name__) #initalize the web application

def camera_frames():
    #the camera feed for the page

    vc = cv2.VideoCapture(0) #temporary taking of video feed from computer camera

    while True:
        success, frame = vc.read() #read the camera frame
        (frame_height, frame_width) = frame.shape[:2] #save the current frame size

        resize_percent = 0.50 #rescale the frame by 50%

        #create scaled frame size
        rescale_frame_width = int(frame_width * resize_percent)
        rescale_frame_height = int(frame_height * resize_percent)

        #save dimensions for resize scaling`
        dimensions = (rescale_frame_width, rescale_frame_height)

        #rescale the frame with cv2's interpolation
        frame = cv2.resize(frame, dimensions, interpolation=cv2.INTER_LINEAR)

        if not success:
            break
        else:
            ret, buffer = cv2.imencode('.jpg', frame)
            outputFrame = buffer.tobytes()
            yield(b'--frame\r\n'
                  b'Content-Type: image/jpeg\r\n\r\n' + outputFrame + b'\r\n')

    vc.release()

def graph_display(): #read in data from the queue
    graphFrameSem.acquire()
    print(graphFrame)
    graph_data = graphFrame
    graphFrameSem.release()
    yield f"data:{graph_data}\n\n"

@app.route('/') #index of the GUI (the viewable page)
def index():
    return render_template('index.html')

@app.route('/video_feed') #video feed route
def video_feed_route():
    return Response(camera_frames(), mimetype = "multipart/x-mixed-replace; boundary=frame")

@app.route('/graph_feed') #graph feed route
def graph_feed_route():
    response = Response(stream_with_context(graph_display()),
    mimetype='text/event-stream')
    response.headers["Cache-Control"] = "no-cache"
    response.headers["X-Accel-Buffering"] = "no"
    return response

@app.route('/calendar_feed', methods=["POST"]) #calendar feed route
def calendar_feed_route():
    retrieve_cal = request.get_json()
    print(retrieve_cal)
    return json.dumps({'success':True}), 200, {'ContentType':'application/json'}

@app.route('/controls_feed', methods=["POST"]) #controls feed route
def controls_feed_route():
    retrieve_output = request.get_json()
    print(retrieve_output)
    return json.dumps({'success':True}), 200, {'ContentType':'application/json'}

@app.route('/read_client', methods=["POST"]) #read data generated by the client
def read_client_route():
    client_data = request.get_json() #get the data from the data client
    #(the Raspberry Pi code)

    graphFrameSem.acquire()
    global graphFrame
    graphFrame = client_data
    graphFrameSem.release()

    return json.dumps({'success':True}), 200, {'ContentType':'application/json'}

if __name__ == "__main__":
    app.run(host="127.0.0.1", port='5000', debug=True, threaded=True, use_reloader=False)
